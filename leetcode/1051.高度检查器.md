# 1051. 高度检查器
[1051. 高度检查器](https://leetcode.cn/problems/height-checker/)

学校打算为全体学生拍一张年度纪念照。根据要求，学生需要按照 非递减 的高度顺序排成一行。

排序后的高度情况用整数数组 expected 表示，其中 expected[i] 是预计排在这一行中第 i 位的学生的高度（下标从 0 开始）。

给你一个整数数组 heights ，表示 当前学生站位 的高度情况。heights[i] 是这一行中第 i 位学生的高度（下标从 0 开始）。

返回满足 heights[i] != expected[i] 的 下标数量 。

### 分析
题目描述的很复杂，其实简单来说就是比较排序后的数组和原数组不一样的位置有多少个。

我们当然可以用各种语言自带的sort，比如`Go`的写法：
```go
func heightChecker(heights []int) int {
    expected := make([]int, len(heights))
    copy(expected, heights)
    sort.Ints(expected)
    res := 0
    for i := range heights {
        if expected[i] != heights[i] {
            res++
        }
    }
    return res
}
```

但是！
这何尝不是一个检验我们自己写的sort是否正确的题目呢？

机会难得，我们就在这里就把每种排序算法实现一遍吧！

#### 快速排序 QuickSort
1. 第一个元素作为pivot `p = s[0]`
2. 从左往右找到第一个比p大的数字：`s[l]>p`时，停
3. 从右往左找到第一个比p小的数字：`s[r]<p`时，停
4. 如果`l>=r`，那么已经排好序了，退出for循环
5. 如果`l<r`, `swap(s[l],s[r])`
6. 如果交换的两个数值相等，那么`l++`或者`r--`进入下一轮循环（此处避免死循环）
5. 否则，开始递归
```go
func quickSort(s []int) {
	if len(s) < 2 {
		return
	}
	p := s[0]
	l := 0
	r := len(s) - 1
	for l < r {
		for s[l] < p {
			l++
		}
		for s[r] > p {
			r--
		}
		if l >= r {
			break
		}
		s[l], s[r] = s[r], s[l]
        if s[l] == s[r] {
			l++
		}
	}
	quickSort(s[:l])
	quickSort(s[l+1:])
}
```